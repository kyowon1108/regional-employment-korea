# -*- coding: utf-8 -*-
"""고용률 분석.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MlnjEihdjbllzcXNFn4cjDv_IlroxOQg
"""

import pandas as pd
df1 = pd.read_csv('/content/최종_통합데이터_수정_cp949.csv', encoding='cp949')
df1.head()

import numpy as np

# 고용률이 0인 경우 결측치로 치환
df1['고용률'] = df1['고용률'].replace(0, np.nan)
df1['취업자'] = df1['취업자'].replace(0, np.nan)

# 고용률이 결측인 행은 모두 제거
df = df1.dropna(subset=['고용률'])

# 로그변환 for E9
df['E9_log'] = np.log1p(df['E9_체류자수'])

print(df1.shape, "→", df.shape)  # 제거 전후 행 개수 비교


df = df.set_index(['시군구', '연도'])

!pip install linearmodels

from linearmodels.panel import PanelOLS
import statsmodels.api as sm

df['제조업log'] =  np.log1p(df['제조업_종사자수'])
df['서비스업log'] =  np.log1p(df['서비스업_종사자수'])
df['산업log비율'] = df['제조업log'] - df['서비스업log']  # == log( (제조+1)/(서비스+1) )

df['interaction'] = df['E9_log'] * df['산업log비율']

mod = PanelOLS.from_formula(
    '고용률 ~ 1 + E9_log + 산업log비율 + interaction + EntityEffects + TimeEffects',
    data=df
)
res = mod.fit(cov_type='clustered', cluster_entity=True)

print(res.summary)

# --- 7) (선택) 한계효과 계산 예시: 산업 구조 분위수에서 E9_log의 기울기 ---
b = res.params
for q in [0.25, 0.50, 0.75]:
    Rq = df['산업log비율'].quantile(q)
    me = b['E9_log'] + b['interaction'] * Rq
    print(f"산업log비율 {int(q*100)}분위({Rq:.3f})에서 E9_log의 한계효과: {me:.4f} p.p. per 1% E9 증가")

"""1. 주요 추정결과

E9_log (0.0774, p<0.001)

외국인 체류자(E9) 수가 1% 증가할 때, 고용률은 평균적으로 약 +0.077 p.p. 상승.

즉, E9의 증가는 고용률을 일관되게 높이는 방향으로 작용.

산업log비율 (0.3309, p<0.001)

제조업/서비스업 종사자 비율이 로그 단위로 증가할수록 고용률은 약 +0.33 p.p. 상승.

제조업이 서비스업보다 상대적으로 많은 지역일수록 고용률이 높음.

상호작용 (–0.0137, p=0.1443)

음(-)의 계수이나 통계적으로 유의하지 않음.

즉, 산업 구조가 E9 효과를 유의하게 조절하지는 않음.

2. 한계효과 (조건부 E9 효과)

25 분위(산업구조 제조업 비중 낮음, –2.109) → +0.106 p.p.

50 분위(중간 수준, –1.239) → +0.094 p.p.

75 분위(제조업 상대적으로 많은, –0.385) → +0.083 p.p.

산업 구조가 제조업 쪽으로 기울수록, 외국인 노동자의 고용률 효과는 약간 감소하나 여전히 양(+)의 효과가 유지.

3. 해석

외국인 노동자 증가 → 고용률 상승이라는 기본 패턴은 산업구조와 무관하게 안정적으로 성립.

제조업 비중이 높아질수록 효과가 약간 줄어들지만, 부정적 전환까지는 가지 않음.

4. 정책적 함의

보편적 효과

외국인 노동자는 한국 시군구 노동시장에서 전반적으로 고용률 제고에 기여.

산업 구조 차이

제조업 비중이 높을수록 효과가 다소 약화되므로, 제조업 의존 지역에는 외국인 노동자를 내국인 고용 확대와 보완하는 방식(예: 숙련 매칭, 생산성 향상형 정책)이 필요.
"""

!pip install koreanize_matplotlib

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import koreanize_matplotlib
# ---------------------------
# 0) 준비: 계수/공분산, 데이터 범위
# ---------------------------
# 결과 객체(res)에서 계수와 공분산행렬 추출
b = res.params
V = res.cov

# 변수명 매핑 (필요시 수정)
name_E9   = 'E9_log'
name_R    = '산업log비율'
name_int  = 'interaction'  # == E9_log * 산업log비율

beta_E9  = b[name_E9]
beta_R   = b[name_R]
beta_int = b[name_int]

var_E9   = V.loc[name_E9, name_E9]
var_int  = V.loc[name_int, name_int]
cov_E9int= V.loc[name_E9, name_int]

# 그리드 설정: E9_log는 관측분포의 5~95백분위, 기준점 x0는 중앙값
x = np.linspace(df[name_E9].quantile(0.05), df[name_E9].quantile(0.95), 50)
x0 = df[name_E9].median()

# 산업log비율 분위수
Rq_list = [
    ('25%', df[name_R].quantile(0.25)),
    ('50%', df[name_R].quantile(0.50)),
    ('75%', df[name_R].quantile(0.75))
]

# ---------------------------
# 1) 단순기울기 그래프 (분위수별 선)
#    y축: Δ고용률(p.p.) = [β_E9 + β_int * Rq] * (E9_log - x0)
#    -> 기준점 x0에서 0으로 정규화해 선형 대비를 명확히 표시
# ---------------------------
plt.figure(figsize=(7,5))
for lab, Rq in Rq_list:
    slope = beta_E9 + beta_int * Rq  # simple slope at R=Rq
    y = slope * (x - x0)
    plt.plot(x, y, label=f'산업log비율 {lab} (R={Rq:.3f})')

plt.axhline(0, linestyle='--', linewidth=1)
plt.xlabel('E9_log')
plt.ylabel('Δ고용률 (p.p.)')
plt.title('상호작용 단순기울기: 산업log비율 분위수별 E9_log 효과')
plt.legend()
plt.tight_layout()
plt.show()

# ---------------------------
# 2) 한계효과 곡선 (연속 R에서의 ∂고용률/∂E9_log)
#    M(R) = β_E9 + β_int * R
#    Var[M(R)] = Var(β_E9) + R^2 Var(β_int) + 2 R Cov(β_E9, β_int)
# ---------------------------
R_grid = np.linspace(df[name_R].quantile(0.02),
                     df[name_R].quantile(0.98), 200)

M = beta_E9 + beta_int * R_grid
Var_M = var_E9 + (R_grid**2)*var_int + 2*R_grid*cov_E9int
SE_M = np.sqrt(np.maximum(Var_M, 0))  # 수치적 안정성

crit = 1.96  # 대략적 95% CI (대표본 근사)
LB = M - crit*SE_M
UB = M + crit*SE_M

plt.figure(figsize=(7,5))
plt.plot(R_grid, M, linewidth=2)
plt.fill_between(R_grid, LB, UB, alpha=0.2, edgecolor='none')
plt.axhline(0, linestyle='--', linewidth=1)
plt.xlabel('산업log비율')
plt.ylabel('E9_log의 한계효과 (p.p. per 1%↑ in E9)')
plt.title('E9_log 한계효과 vs. 산업log비율 (95% CI)')
plt.tight_layout()
plt.show()

# ---------------------------
# 3) Johnson–Neyman 구간(선택):
#    CI가 0을 상회/하회하는 R 범위를 근사적으로 표시
# ---------------------------
sign_pos = (LB > 0)
sign_neg = (UB < 0)

def contiguous_ranges(mask, grid):
    ranges = []
    on = False
    start = None
    for i, m in enumerate(mask):
        if m and not on:
            on = True
            start = grid[i]
        if on and (i == len(mask)-1 or not mask[i+1]):
            end = grid[i]
            ranges.append((start, end))
            on = False
    return ranges

pos_ranges = contiguous_ranges(sign_pos, R_grid)
neg_ranges = contiguous_ranges(sign_neg, R_grid)

print("JN 양(+) 유의 구간(약 95%):", [(round(a,3), round(b,3)) for a,b in pos_ranges])
print("JN 음(-) 유의 구간(약 95%):", [(round(a,3), round(b,3)) for a,b in neg_ranges])